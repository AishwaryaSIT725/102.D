name: Deploy to AKS (Production)

on:
  push:
    branches: ["main"]

env:
  RG: rg-sit722
  AKS: aks-sit722
  NAMESPACE: sit722-prod

jobs:
  deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.RG }}
          cluster-name: ${{ env.AKS }}

      # ---- Render a prod copy of manifests with namespace swapped ----
      - name: Prepare manifests for prod namespace
        run: |
          set -euo pipefail
          rm -rf _render
          mkdir -p _render
          cp -r k8s/* _render/

          # 1) Update the Namespace object name (sit722 -> sit722-prod)
          if [ -f _render/namespace.yaml ]; then
            sed -i -E "s/^(\\s*name:\\s*)sit722\\s*$/\\1${NAMESPACE}/" _render/namespace.yaml
          fi

          # 2) Update only metadata.namespace fields from sit722 -> ${NAMESPACE}
          #    (leave config/secret *names* like ecomm-config-sit722 untouched)
          #    Replace lines that *contain* 'namespace: sit722' exactly.
          grep -rl --include="*.yaml" "namespace: sit722" _render | xargs -r sed -i -E "s/^(\\s*)namespace:\\s*sit722\\s*$/\\1namespace: ${NAMESPACE}/"

      - name: Create/ensure namespace
        run: |
          kubectl get namespace "${NAMESPACE}" >/dev/null 2>&1 || kubectl create namespace "${NAMESPACE}"

      - name: Apply ALL manifests to prod (idempotent)
        run: |
          set -euo pipefail
          # Apply Namespace first
          if [ -f _render/namespace.yaml ]; then
            kubectl apply -f _render/namespace.yaml
          fi
          # Then the rest into the prod namespace
          kubectl -n "${NAMESPACE}" apply -f _render/secrets.yaml
          kubectl -n "${NAMESPACE}" apply -f _render/configmaps.yaml
          kubectl -n "${NAMESPACE}" apply -f _render/rabbitmq.yaml
          kubectl -n "${NAMESPACE}" apply -f _render/customer-db.yaml
          kubectl -n "${NAMESPACE}" apply -f _render/product-db.yaml
          kubectl -n "${NAMESPACE}" apply -f _render/order-db.yaml
          kubectl -n "${NAMESPACE}" apply -f _render/customer-service.yaml
          kubectl -n "${NAMESPACE}" apply -f _render/product-service.yaml
          kubectl -n "${NAMESPACE}" apply -f _render/order-service.yaml
          kubectl -n "${NAMESPACE}" apply -f _render/nginx-config.yaml
          kubectl -n "${NAMESPACE}" apply -f _render/frontend.yaml

      - name: Show what exists
        run: kubectl -n "${NAMESPACE}" get deploy,po,svc -o wide || true

      - name: Wait for LoadBalancer EXTERNAL-IPs (discover + non-fatal)
        run: |
          set +e
          SVCS=$(kubectl -n "${NAMESPACE}" get svc --field-selector spec.type=LoadBalancer -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')
          if [ -z "$SVCS" ]; then
            echo "No LoadBalancer services found in ${NAMESPACE}"
            exit 0
          fi
          echo "LoadBalancer services: $SVCS"
          for s in $SVCS; do
            echo "Waiting for EXTERNAL-IP on service/$s ..."
            for i in {1..40}; do
              IP=$(kubectl -n "${NAMESPACE}" get svc "$s" -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              HOST=$(kubectl -n "${NAMESPACE}" get svc "$s" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
              if [ -n "$IP" ] || [ -n "$HOST" ]; then
                echo "::notice title=$s EXTERNAL-IP::${IP:-$HOST}"
                break
              fi
              sleep 15
            done
          done

      - name: Show services (IPs)
        run: kubectl get svc -n "${NAMESPACE}" -o wide
